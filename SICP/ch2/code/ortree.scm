(define (entry tree)
  (car tree)
)

(define (left-branch tree)
  (cadr tree)
)

(define (right-branch tree)
  (caddr tree)
)

(define (make-tree entry left right)
  (list entry left right)
)

(define (element-of-tree x tree)
  (cond ((null? tree) #f)
        ((= x (entry tree)) #t)
        ((< x (entry tree)) (element-of-tree x (left-branch tree)))
        (else (element-of-tree x (right-branch tree)))        
  )
)

(define (adjoin-tree x tree)
  (cond ((null? tree) (make-tree x '() '()))
        ((= x (entry tree)) tree)
        ((< x (entry tree)) (make-tree (entry tree) (adjoin-tree x (left-branch tree)) (right-branch tree)))
        (else (make-tree (entry tree) (left-branch tree) (adjoin-tree x (right-branch tree))))        
  )
)

; 2.63
(define (tree-to-list1 tree)
  (if (null? tree) '()
      (append (tree-to-list1 (left-branch tree)) (cons (entry tree) (tree-to-list1 (right-branch tree))))
  )
)

(define (tree-to-list2 tree)
  (define (copy-to-list tr res)
    (if (null? tr) res
        (copy-to-list (left-branch tr) (cons (entry tr) (copy-to-list (right-branch tr) res)))
    )
  )
  
  (copy-to-list tree '())
)

(define x (list 7 (list 3 (list 1 '() '()) (list 5 '() '())) (list 9 '() (list 11 '() '()))))

(define y (list 3 (list 1 '() '()) (list 7 (list 5 '() '()) (list 9 '() (list 11 '() '())))))

(define z (list 5 (list 3 (list 1 '() '()) '()) (list 9 (list 7 '() '()) (list 11 '() '()))))

(define (list-to-tree elements)
  (car (partial-tree elements (length elements)))
)

(define (partial-tree elts n)
  (if (= n 0) (cons '() elts)
      (let ((left-size (quotient (- n 1) 2))) 
           (let ((left-result (partial-tree elts left-size)))
                (let ((left-tree (car left-result)) 
                      (non-left-elts (cdr left-result))
                      (right-size (- n (+ left-size 1)))
                     ) 
                     (let ((this-entry (car non-left-elts))
                           (right-result (partial-tree (cdr non-left-elts) right-size))
                          ) 
                          (let ((right-tree (car right-result))
                                (remaining-elts (cdr right-result))
                               ) 
                               (cons (make-tree this-entry left-tree right-tree) remaining-elts)
                          )
                     )
                )                
           )
      )
  )
)

; 2.65
(define (union-tree tr1 tr2)
  (define (union-order or1 or2)
    (cond ((null? or1) or2)
          ((null? or2) or1)
          ((= (car or1) (car or2)) (cons (car or1) (union-order (cdr or1) (cdr or2))))
          ((< (car or1) (car or2)) (cons (car or1) (union-order (cdr or1) or2)))
          (else (cons (car or2) (union-order or1 (cdr or2))))
    )
  )
  (let ((ls1 (tree-to-list2 tr1))) 
       (let ((ls2 (tree-to-list2 tr2))) 
            (let ((us (union-order ls1 ls2))) (list-to-tree us))
       )
  )
)

(define (intersection-tree tr1 tr2)
  (define (intersection-order or1 or2)
    (if (or (null? or1) (null? or2)) '()
        (let ((x1 (car or1))
              (x2 (car or2))
             )
             (cond ((= x1 x2) (cons x1 (intersection-order (cdr or1) (cdr or2))))
                   ((< x1 x2) (intersection-order (cdr or1) or2))
                   ((> x1 x2) (intersection-order or1 (cdr or2)))
             )
        )
    )
  )
  (let ((ls1 (tree-to-list2 tr1))) 
       (let ((ls2 (tree-to-list2 tr2))) 
            (let ((us (intersection-order ls1 ls2))) (list-to-tree us))
       )
  )
)

(define tr1 '(6 (4 () (5 () ())) (10 (8 () ()) ())))   
(define tr2 '(3 (2 (1 () ()) ()) (7 () (8 () (9 () ())))))