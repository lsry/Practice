(define (assoc key records)
  (cond ((null? records) #f)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))
  )
)

(define (lookup-single key table)
  (let ((record (assoc key (cdr table))))
       (if record (cdr record) #f)
  )
)

(define (insert-single! key value table)
  (let ((record (assoc key (cdr table))))
       (if record (set-cdr! record value)
           (set-cdr! table (cons (cons key value) (cdr table)))
       )
  )
)

(define (make-table)
  (list '*table*)
)

(define (lookup-double key-child key table)
  (let ((subtable (assoc key-child (cdr table))))
       (if subtable
           (let ((record (assoc key (cdr subtable))))
                (if record (cdr record) #f)
           )
           #f
       )
  )
)

(define (insert-double! key-child key value table)
  (let ((subtable (assoc key-child (cdr table))))
       (if subtable (let ((record (assoc key (cdr subtable))))
                         (if record (set-cdr! record value)
                                    (set-cdr! subtable (cons (cons key value) (cdr subtable)))
                         )
                    )
                    (set-cdr! table (cons (list key-child (cons key value)) (cdr table)))
       )
  )
)

(define (make-double-table)
  (let ((local-table (list '*table*))) 
       (define (look-up key-1 key-2)
         (let ((subtable (assoc key-1 (cdr local-table)))) 
              (if subtable (let ((record (assoc key-2 (cdr subtable))))
                                (if record (cdr record) #f)
                           )
                           #f
              )
         )
       )
       (define (insert! key-1 key-2 value)
         (let ((subtable (assoc key-1 (cdr local-table))))
              (if subtable (let ((record (assoc key-2 (cdr subtable)))) 
                                (if reocrd (set-cdr! record value)
                                           (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))
                                )
                           )
                           (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table)))
              )
         )
       )
       (define (dispatch m)
         (cond ((eq? m 'lookup-proc) look-up)
               ((eq? m 'insert-proc) insert!)
               (else (error "Unknow operation -- TABLE" m))
         )
       )
       dispatch
  )
)

(define operation-table (make-double-table))

(define get (operation-table 'lookup-proc))

(define put (operation-table 'insert-proc))

; 3.24
(define (make-table-num same-key?)
  (define (assoc-num key records)
    (cond ((null? records) #f)
          ((same-key? key (caar records)) (car records))
          (else (assoc-num key (cdr records)))
    ) 
  )
  (let ((local-table (list '*table*))) 
       (define (look-up key-1 key-2)
         (let ((subtable (assoc-num key-1 (cdr local-table)))) 
              (if subtable (let ((record (assoc-num key-2 (cdr subtable))))
                                (if record (cdr record) #f)
                           )
                           #f
              )
         )
       )
       (define (insert! key-1 key-2 value)
         (let ((subtable (assoc-num key-1 (cdr local-table))))
              (if subtable (let ((record (assoc-num key-2 (cdr subtable)))) 
                                (if reocrd (set-cdr! record value)
                                           (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))
                                )
                           )
                           (set-cdr! local-table (cons (list key-1 (cons key-2 value)) (cdr local-table)))
              )
         )
       )
       (define (dispatch m)
         (cond ((eq? m 'lookup-num-proc) look-up)
               ((eq? m 'insert-num-proc) insert!)
               (else (error "Unknow operation -- TABLE" m))
         )
       )
       dispatch
  )
)

; 3.25
(define (make-mul-table)
  (define (assoc key records)
    (cond ((null? records) #f)
          ((equal? key (caar records)) (car records))
          (else (assoc key (cdr records)))
    )
  )
  (define (iter-assoc keys table)
    (if (null? keys) table
        (let ((records (assoc (car keys) (cdr table)))) 
             (if records (iter-assoc (cdr keys) records) #f) 
        )
    )
  )
  ; 当此关键字之后都不存在时，新建列表存储
  (define (join-table! ls var tab)
    (cond ((null? ls) tab)
          ((null? (cdr ls)) (set-cdr! tab (cons (cons (car ls) var) (cdr tab))) tab)
          (else (let ((new-ls (list (car ls))))
                     (set-cdr! tab (cons (join-table! (cdr ls) var new-ls) (cdr tab)))
                     tab
                )
          )
    )
  )
  (define (insert! keys value tables)
     (cond ((null? keys) (error "NULL KEYS"))
           ((null? (cdr tables)) (join-table! keys value tables)) ;when local-list is null
           ((null? (cdr keys)) (let ((record (assoc (car keys) (cdr tables))))
                                    (if record (set-cdr! record value)
                                        (set-cdr! tables (cons (cons (car keys) value) (cdr tables)))
                                    )               
                               )
            )
            (else (let ((records (assoc (car keys) (cdr tables))))
                       (if records (insert! (cdr keys) value records) ;存在当前关键字
                           (join-table! keys value tables)
                       )
                  )
            )
    )
  )
  (let ((local-table (list '*table*)))
       (define (look-up keys)
         (let ((record (iter-assoc keys local-table))) 
              (if record (cdr record) #f)
         )
       )
       (define (insert-mul! keys value)
         (insert! keys value local-table)
       )       
       (define (dispatch m)
         (cond ((eq? m 'lookup-mul-proc) look-up)
               ((eq? m 'insert-mul-proc) insert-mul!)
               ((eq? m 'print-mul) local-table)
               (else (error "Unknow operation -- TABLE" m))
         )
       )
       dispatch
  )
)

;(define m (make-mul-table))
;((m 'insert-mul-proc) '(a b) 2)
;((m 'lookup-mul-proc) '(a b))

(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))
  )
)

(define (memorize f)
  (let ((table (make-table))) 
       (lambda (x) 
         (let ((previously-computed-result (lookup-single x table)))
              (or previously-computed-result 
                  (let ((result (f x))) 
                        (insert-single! x result table) result
                  )
              )
         )
       )
  )
)

(define memo-fib
  (memorize (lambda (n) 
              (cond ((= n 0) 0)
                    ((= n 1) 1)
                    (else (+ (memo-fib (- n 1)) (memo-fib (- n 2))))
              )
            )
  )
)

(define memo-fib2 (memorize fib))
