## Capter 12 二叉搜索树

### 12.1 什么是二叉搜索树

#### 12.1-1      
1. **高度为2：** 高度为 2 最多有 3 个元素，而集合有 7 个，所以不满足。 
2. **高度为3：** ![](img/1211a.png)      
3. **高度为4：** ![](img/1211b.png) 
4. **高度为5：** ![](img/1211c.png) 
5. **高度为6：** ![](img/1211d.png) 
6. **高度为7：** ![](img/1211e.png)         

#### 12.1-2         
1. **最小堆性质：** 某结点值在以该结点作为根的子树中值最小        
   **二叉搜索树性质：** 左孩子结点及后代结点的值小于等于根结点的值，右孩子结点及后代结点的值大于根结点的值。          
2. 无法在线性时间内完成，因为没办法知道哪一个孩子有最小值，需要进行比较，因而最佳时间为 O(nlgn)               

#### 12.1-3     
[简单，栈 inOrderIterStack](code/BinSearchTree.java)      

#### 12.1-4 
更换一下中序遍历的顺序即可  

#### 12.1-5           
在建立二叉搜索树的过程中，插入的结点总要与路径上的结点进行比较，到达当前搜索树的叶结点处（该结点的位置），对于 n 个结点来说，最少的比较次数为 Ω(nlgn) , 因此最坏情况下需要 Ω(nlgn) 时间。          

### 12.2 查询二叉搜索树        

#### 12.2-1          
对于 X = < x1, x2, ..., xn > , 若 xi < xj , 则任意 x ∈ {x_j+1,..., xn} xi < x ;               
所以 e 不符合 ， 因为 347 < 621 ，而 347 > 299       

#### 12.2-2       
[minNodeRecu, maxNodeRecu](code/BinSearchTree.java)          

#### 12.2-3            
[predecessor](code/BinSearchTree.java)         

#### 12.2-4          
![](img/1224.png)          
如图所示，根节点为 3 ， 查找 6 ， A = {4} , B = {3,5,6} , C = {}        
存在 a = 4 , b = 3 , 使得 a > b ;           

#### 12.2-5           
证明：当前结点为 n ，左孩子为 l , 右孩子为 r , 后继为 c , 前驱为 p ;则 p.k <= n.k <= c.k     
假设后继 c 存在左孩子 cl , 那么 cl.k <= c.k ， 可得到 n.k <= cl.k <= c.k ， 则 cl 为后继；     
前驱同理可证没有右孩子；            

#### 12.2-6             
