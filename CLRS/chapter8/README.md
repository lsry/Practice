## Chapter 8  线性时间排序

### 8.1 排序算法的下界

#### 8.1-1
当输入的数据已经排序好，形成以下比较序列：1:2,2:3，。。。，n-1：n,此时形成最小深度 (n-1)   

#### 8.1-2
![812](img/812.gif)   

#### 8.1-3
要达到线性时间，则做的结果在决策树上应该在高度为n的位置。此时最多的叶子数最多有 2^n 个，总的叶子数有 n! 个；   
* 达到 1/2 , 因为![813](img/813a.gif) ,所以不存在。    
* 达到 1/n ，因为 lg(n-1)! > n -> 2^n/n! < 1/n  也不成立。    
* 达到 1/2^n , 因为 2^n/n! > 1/2^n ,所以存在。

#### 8.1-4
对于每一个子序列，总共有 k! 种输出，有 n/k 个子序列，也就总共有 (k!)^(n/k) 个输出情况，由 2^ >= (k!)^(n/k)     
所以： h >= (n/k)lg(k!) = Ω(nlgk)     

### 8.2 计数排序   

#### 8.2-1   
* A:{6,0,2,0,1,3,4,6,1,3,2} C:{2,2,2,3,1,0,2}      C:{2,4,6,8,9,9,11}  B{ , , , , , , , , , , }   
* B{ , , , , , 2 , , , , , }   C:{2,4,5,8,9,9,11}  
* B{ , , , , , 2 ,  , 3 , , , }   C:{2,4,5,7,9,9,11}  
* B{ , , , 1 , , 2 ,  , 3 , , , }   C:{2,3,5,7,9,9,11}  
* B{ , , , 1 , , 2 ,  , 3 , , , 6 }   C:{2,3,5,7,9,9,10}  
* B{ , , , 1 , , 2 ,  , 3 , 4 , , 6 }   C:{2,3,5,7,8,9,10}
* B{ , , , 1 , , 2 , 3  , 3 , 4 , , 6 }   C:{2,3,5,6,8,9,10}
* B{ , , 1 , 1 , , 2 , 3  , 3 , 4 , , 6 }   C:{2,2,5,6,8,9,10}
* B{ , 0 , 1 , 1 , , 2 , 3  , 3 , 4 , , 6 }   C:{1,2,5,6,8,9,10}
* B{ , 0 , 1 , 1 , 2 , 2 , 3  , 3 , 4 , , 6 }   C:{1,2,4 ,6,8,9,10}    
* B{ 0 , 0 , 1 , 1 , 2 , 2 , 3  , 3 , 4 , 6 , 6 }   C:{0,2,4 ,6,8,9,9}    

#### 8.2-2   
根据第10 ~ 12行，C计算出现的个数，对应于A中在正确序列上的位置，在统计完后,C中的数较大，当从数组最后一个开始填入，对于相同的元素，位于较后的填入大的位置上，因而是稳定的。    

#### 8.2-3   
证明：  
* 当j = 0，B 数组为空，相当于元素已经到了合适的位置 ；  
* 当前面 j 个元素已经在B中到了合适的位置，第 j+1 个元素的位置有两种情况: 1) 之前没有出现过相同元素，那么B[C[A[j+1]]]为空，是对应A[j+1]的合适位置，2) 出现过相同元素，那么由于第一次出现时 C[A[j']] = C[A[j']] - 1 ，所以B[C[A[j+1]]]为空，是对应A[j+1]的合适位置；   
* 当终止时，所有元素都到了合适的位置，因而算法正确。   
* 由于 j = j + 1,所以前面的元素位于后面的位置，所以不稳定。   

#### 8.2-4 [intervals](NumSort.java)   

### 8.3 基数排序  
    
