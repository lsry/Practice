## Chapter 7  快速排序

### 7.1 快速排序的描述

#### 7.1-1
1. [[13],19,[9],5,12,8,7,4,21,2,6,{11}]
2. [9,[19],13,[5],12,8,7,4,21,2,6,{11}]
3. [9,5,[13],19,12,[8],7,4,21,2,6,{11}]
4. [9,5,8,[19],12,13,[7],4,21,2,6,{11}]
5. [9,5,8,7,[12],13,19,[4],21,2,6,{11}]
6. [9,5,8,7,4,[13],19,12,21,[2],6,{11}]
7. [9,5,8,7,4,2,[19],12,21,13,[6],{11}]
8. [9,5,8,7,4,2,6,{12},21,13,19,{11}]
9. [9,5,8,7,4,2,6,{11},21,13,19,12]

#### 7.1-2  
* 相同时，返回r;
* if (i+1 == r && A[i+1] == A[r])  return (p+q)/2    

#### 7.1-3
证明：在程序4 ~ 6行若运行则是时间最多的步骤，从j = p ~ r-1 ,而4~6行是常量时间，因此T(n) = Σ1 = n = O(n)    

#### 7.1-4
将4行 A[j] <= x 替换为 A[j] >= x    

### 7.2 快速排序的性能

#### 7.2-1
证明：
* 假设 T(n) <= cn^2 , T(1) = c   
T(n) = c(n-1)^2 + n = cn^2 - [(2c-1)n+c]    
当 2c-1 >= 0 -> c >= 1/2 时，    
T(n) <= cn^2 = O(n^2)    
* 假设 T(n) >= dn^2 , T(1) = d   
T(n) = d(n-1)^2 + n = dn^2 + [(1-2d)n+d]   
当 1-2d >= 0 -> d <= 1/2 时，   
T(n) >= dn^2 = Ω(n^2)    
* T(n) = Θ(n^2)    

#### 7.2-2
T(n) = Θ(n^2)   

#### 7.2-3
证明：当元素互异时，每当选取最后一个元素为主元，会划分成（n-1）个元素 和 0 个元素的两个集合，所以 T(n) = T(n-1) + θ(n) = θ(n^2)。   

#### 7.2-4
证明：   
* 对于INSERTION-SORT，已经有序的输入，便不会做内层循环的移动操作，因而时间接近于θ(n)；
* 对于QUICKSORT，已经有序的输入，会划分成（n-1）个元素 和 0 个元素的两个集合，所以 T(n) = T(n-1) + θ(n) = θ(n^2)；
* 所以INSERTION-SORT性能更好。

#### 7.2-5
证明：  
* 最短的路径为 n , nα , nα^2 , ... , nα^h , ... , 1    
令 nα^h = 1 -> h = log_α(1/n) = -lgn/lgα    

* 最长的路径为：n , n(1-α) , n(1-α)^2 , ... , n(1-α)^h , ... , 1   
令 n(1-α)^h = 1 -> h = log_(1-α)(1/n) = -lgn/lg(1-α)      

#### 7.2-6   
证明：对于一个n个元素的数组，以α：1-α进行划分，不妨设有nα个小于主元的元素，n(1-α)个大于主元的元素，若更平衡，新的划分α'满足α < α' <= 1/2 , 所以：  
![726](img/726.gif)

### 7.3 快速排序的随机化版本

#### 7.3-1
因为当输入分布不再影响顺序，而是由随机过程决定，那么最坏情况的发生的概率也就减小了，最可能出现的是平均情况，因此用期望运行时间。

#### 7.3-2
* 最好情况：Θ(lgn)   
* 最坏情况：Θ(n)    

### 7.4 快速排序分析  

#### 7.4-1
证明：假设T(n) ≥ cn^2    
T(n) ≥ min(cq^2 + c(n-1-q)^2) + Θ(n) = cmin(q^2 + (n-1-q)^2) + Θ(n) {1 ≤ q ≤ n-1}    
对于f(q) = q^2 + (n-1-q)^2  {1 ≤ q ≤ n-1}    
令f'(q) = 4q - 2n + 2 = 0  ->  q = (n-1)/2     
∵ f''(q) = 4 > 0  ∴ f(q) 当q = (n-1)/2取极小值   
∴ 当c充分大时， T(n) ≥ c/2(n-1)^2 + Θ(n) ≥ cn^2 + c/2(1-n^2-2n) ≥ cn^2    
∴ T(n) = Ω(n^2)     

#### 7.4-2
证明：由于在最好的时候 T(n) = 2T(n/2) + Θ(n)    
假设T(n) ≥ cnlgn    
∴ T(n) ≥ 2cn/2lg(n/2) + Θ(n) = cnlgn - cn ≥ cnlgn        
∴ T(n) = Ω(nlgn)    

#### 7.4-3   
证明：已经由**7.4-1**得出一阶导数在q = (n-1)/2 处有极小值，在[0,(n-1)/2]为减函数，[(n-1)/2,(n-1)]为增函数，所以在端点处有最大值，由于q = 0 和 q = n-1 两值相等，所以在q = 0 和 q = n-1 处有最大值。     

#### 7.4-4   
![744](img/744.gif)

#### 7.4-5
如图：![745a](img/745a.jpg)    
树的高度为：n(1/2)^h = k -> h = lg(n/k)   
每层代价为cn , 所以快速排序部分为O(nlg(n/k))   
每k个元素为插入排序，总共有2^(lg(n/k)) = n/k 个叶子，所以插入排序部分为O(k^2 * n/k) = O(nk)    
综上所述，期望运行时间为O(nk+nlg(n/k))    
理论上：nk + nlg(n/k) ≤ nlgn -> k-lgk ≤ 0   

#### 7.4-6   


### 思考题

#### 7-1  
